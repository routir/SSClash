#!/bin/sh

# This script configures nftables or iptables to redirect network traffic
# through the Clash proxy based on settings defined in /opt/clash/settings.
# It supports two modes:
# 1. Exclude Mode: Proxies all traffic except from specified interfaces (e.g., WAN).
# 2. Explicit Mode: Proxies traffic ONLY from specified interfaces (e.g., LAN bridge).

CONFIG_FILE="/opt/clash/config.yaml"
SETTINGS_FILE="/opt/clash/settings"

readonly RESERVED_NETWORKS="0.0.0.0/8 10.0.0.0/8 100.64.0.0/10 127.0.0.0/8 169.254.0.0/16 172.16.0.0/12 192.0.2.0/24 192.88.99.0/24 192.168.0.0/16 198.51.100.0/24 203.0.113.0/24 224.0.0.0/4 240.0.0.0/4 255.255.255.255/32"

# --- Global Settings Variables ---
# These are populated by load_all_settings_once() to avoid repeated file reads.
MODE="exclude"
AUTO_DETECT_LAN="true"
AUTO_DETECT_WAN="true"
BLOCK_QUIC="true"
DETECTED_LAN=""
DETECTED_WAN=""
INCLUDED_INTERFACES=""
EXCLUDED_INTERFACES=""

# Function to log messages
msg() {
    logger -p daemon.info -st "clash-rules[$$]" "$*"
}

# Function to load all settings from the settings file into global variables.
# This is called only once to improve performance.
load_all_settings_once() {
    if [ ! -f "$SETTINGS_FILE" ]; then
        msg "Settings file not found. Using default values."
        return
    fi

    while IFS='=' read -r key value; do
        case "$key" in
            "INTERFACE_MODE") MODE="$value" ;;
            "AUTO_DETECT_LAN") AUTO_DETECT_LAN="$value" ;;
            "AUTO_DETECT_WAN") AUTO_DETECT_WAN="$value" ;;
            "BLOCK_QUIC") BLOCK_QUIC="$value" ;;
            "DETECTED_LAN") DETECTED_LAN="$value" ;;
            "DETECTED_WAN") DETECTED_WAN="$value" ;;
            "INCLUDED_INTERFACES") INCLUDED_INTERFACES="$value" ;;
            "EXCLUDED_INTERFACES") EXCLUDED_INTERFACES="$value" ;;
        esac
    done < "$SETTINGS_FILE"

    local settings_part=""

    [ -n "$MODE" ] && settings_part="$settings_part, Mode: $MODE"
    [ -n "$AUTO_DETECT_LAN" ] && settings_part="$settings_part, Auto-detect LAN: $AUTO_DETECT_LAN"
    [ -n "$AUTO_DETECT_WAN" ] && settings_part="$settings_part, Auto-detect WAN: $AUTO_DETECT_WAN"
    [ -n "$BLOCK_QUIC" ] && settings_part="$settings_part, Block QUIC: $BLOCK_QUIC"
    [ -n "$DETECTED_LAN" ] && settings_part="$settings_part, Detected LAN: $DETECTED_LAN"
    [ -n "$DETECTED_WAN" ] && settings_part="$settings_part, Detected WAN: $DETECTED_WAN"
    [ -n "$INCLUDED_INTERFACES" ] && settings_part="$settings_part, Included interfaces: '$INCLUDED_INTERFACES'"
    [ -n "$EXCLUDED_INTERFACES" ] && settings_part="$settings_part, Excluded interfaces: '$EXCLUDED_INTERFACES'"

    if [ -n "$settings_part" ]; then
        msg "Settings loaded: ${settings_part#*, }"
    else
        msg "Settings loaded (no values specified in settings file)."
    fi
}

# Function to check if a string is a valid IP address
is_valid_ip() {
    local ip="$1"
    echo "$ip" | grep -qE '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
}

# Function to resolve domain name to IP addresses
resolve_domain() {
    local domain="$1"
    local resolved_ips=""

    # Use nslookup to resolve the domain
    if command -v nslookup >/dev/null 2>&1; then
        resolved_ips=$(nslookup "$domain" 2>/dev/null | awk '/^Address: / { print $2 }' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')
    fi

    # If nslookup failed or not available, try using getent
    if [ -z "$resolved_ips" ] && command -v getent >/dev/null 2>&1;
    then
        resolved_ips=$(getent hosts "$domain" 2>/dev/null | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')
    fi

    # Ensure each IP is on a separate line and remove duplicates
    if [ -n "$resolved_ips" ]; then
        echo "$resolved_ips" | tr ' ' '\n' | grep -v '^$' | sort -u
    fi
}

# Function to check if chain exists (iptables only)
chain_exists() {
    local table="$1"
    local chain="$2"
    iptables -t "$table" -L "$chain" >/dev/null 2>&1
}

# Function to extract fake-ip configuration from config.yaml
extract_fake_ip_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        return 1
    fi

    # Use awk to parse DNS section and extract both fake-ip-range and fake-ip-filter-mode
    awk '
    /^dns:/ { in_dns = 1; next }
    /^[a-zA-Z]/ && !/^  / { in_dns = 0 }
    in_dns && /enable:/ {
        gsub(/^[[:space:]]*enable:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        if ($0 == "true") enable = "true"
    }
    in_dns && /enhanced-mode:/ {
        gsub(/^[[:space:]]*enhanced-mode:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        if ($0 == "fake-ip") mode = "fake-ip"
    }
    in_dns && /fake-ip-range:/ {
        gsub(/^[[:space:]]*fake-ip-range:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        range = $0
    }
    in_dns && /fake-ip-filter-mode:/ {
        gsub(/^[[:space:]]*fake-ip-filter-mode:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        filter_mode = tolower($0)
    }
    END {
        if (enable == "true" && mode == "fake-ip" && range != "") {
            # Use blacklist as default if filter_mode is not specified
            print range "|" (filter_mode ? filter_mode : "blacklist")
        }
    }
    ' "$CONFIG_FILE"
}

# Extract server IPs from config.yaml
extract_server_ips() {
    if [ ! -f "$CONFIG_FILE" ]; then
        msg "ERROR: Config file not found: $CONFIG_FILE"
        return 1
    fi

    # Extract servers using awk
    local servers=$(awk '
    /^proxies:/ { in_proxies = 1; next }
    /^[a-zA-Z]/ && !/^  / { in_proxies = 0 }
    in_proxies && /server:/ {
        gsub(/^[[:space:]]*server:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        if ($0 != "") print $0
    }
    ' "$CONFIG_FILE")

    # Process each server entry
    if [ -n "$servers" ]; then
        echo "$servers" | while IFS= read -r server; do
            [ -z "$server" ] && continue

            if is_valid_ip "$server"; then
                # It's already an IP address
                echo "$server"
            else
                # It's a domain name, resolve it
                resolved_ips=$(resolve_domain "$server")
                if [ -n "$resolved_ips" ]; then
                    echo "$resolved_ips"
                else
                    msg "WARNING: Could not resolve domain: $server"
                fi
            fi
        done
    fi
}

# Function to get all available interfaces
get_all_interfaces() {
    local all_interfaces=""

    # From /sys/class/net
    if [ -d "/sys/class/net" ]; then
        for iface_path in /sys/class/net/*; do
            [ -d "$iface_path" ] || continue
            local name=$(basename "$iface_path")
            [ "$name" != "lo" ] || continue

            # Check interface state
            local operstate=""
            if [ -f "$iface_path/operstate" ]; then
                operstate=$(cat "$iface_path/operstate" 2>/dev/null)
            fi

            # Add active interfaces or bridges
            if [ "$operstate" = "up" ] || [ -d "$iface_path/bridge" ] || [ -f "$iface_path/brif" ]; then
                all_interfaces="$all_interfaces $name"
            fi
        done
    fi

    # Via ip link
    if command -v ip >/dev/null 2>&1; then
        all_interfaces="$all_interfaces $(ip link show 2>/dev/null | awk -F': ' '/^[0-9]+:/ && !/lo:/ {print $2}' | cut -d'@' -f1)"
    fi

    # Via brctl (for bridge interfaces)
    if command -v brctl >/dev/null 2>&1; then
        all_interfaces="$all_interfaces $(brctl show 2>/dev/null | awk 'NR>1 && $1!="" {print $1}')"
    fi

    # Remove duplicates and return a space-separated list
    echo "$all_interfaces" | tr ' ' '\n' | grep -v '^$' | sort -u | tr '\n' ' '
}

# Function to detect LAN bridge
get_lan_interface() {
    # Skip if auto-detection is disabled
    if [ "$AUTO_DETECT_LAN" = "false" ]; then
        return
    fi

    # First, try to use saved result
    if [ -n "$DETECTED_LAN" ] && [ -d "/sys/class/net/$DETECTED_LAN" ]; then
        msg "Using saved LAN interface: $DETECTED_LAN"
        echo "$DETECTED_LAN"
        return 0
    fi

    # Fallback to detection if saved result is invalid
    msg "Saved LAN interface not found or invalid, detecting..."
    local bridge=""

    # Check UCI configuration
    if command -v uci >/dev/null 2>&1; then
        local lan_device=$(uci get network.lan.device 2>/dev/null || uci get network.lan.ifname 2>/dev/null)
        if [ -n "$lan_device" ] && [ -d "/sys/class/net/$lan_device" ]; then
            bridge="$lan_device"
            msg "LAN interface detected via UCI: $bridge"
        fi
    fi

    # Check all interfaces for bridge with LAN IP
    if [ -z "$bridge" ]; then
        for iface in $(get_all_interfaces); do
            # Check if it's a bridge
            if [ -d "/sys/class/net/$iface/bridge" ] || [ -d "/sys/class/net/$iface/brif" ]; then
                 # Check IP address
                 local ip=$(ip addr show "$iface" 2>/dev/null | awk '/inet / && !/127\./ {print $2}' | head -1)
                 if [ -n "$ip" ]; then
                    case "$ip" in
                        192.168.*|10.*|172.1[6-9].*|172.2[0-9].*|172.3[01].*)
                            bridge="$iface"
                            msg "LAN bridge detected: $bridge (IP: ${ip%/*})"
                            break
                            ;;
                    esac
                 fi
            fi
        done
    fi

    echo "$bridge"
}

# Function to detect WAN interface
get_wan_interface() {
    # Skip if auto-detection is disabled
    if [ "$AUTO_DETECT_WAN" = "false" ]; then
        return
    fi

    # First, try to use saved result
    if [ -n "$DETECTED_WAN" ] && [ -d "/sys/class/net/$DETECTED_WAN" ]; then
        msg "Using saved WAN interface: $DETECTED_WAN"
        echo "$DETECTED_WAN"
        return 0
    fi

    # Fallback to detection if saved result is invalid
    msg "Saved WAN interface not found or invalid, detecting..."
    local wan_interface=""

    # Get interface through which default route passes
    wan_interface=$(ip route show default 2>/dev/null | awk '/default via/ {print $5}' | head -1)

    # Check routing table
    if [ -z "$wan_interface" ]; then
        wan_interface=$(awk '$2 == "00000000" { print $1; exit }' /proc/net/route 2>/dev/null)
    fi

    # Check UCI configuration
    if [ -z "$wan_interface" ] && command -v uci >/dev/null 2>&1; then
        wan_interface=$(uci get network.wan.device 2>/dev/null || uci get network.wan.ifname 2>/dev/null)
    fi

    if [ -n "$wan_interface" ]; then
        msg "WAN interface detected: $wan_interface"
    fi

    echo "$wan_interface"
}

# Function to get interfaces for processing (explicit mode) - with deduplication and clear logging
get_included_interfaces() {
    local auto_detected_list=""
    local user_selected_list=""
    local combined_list=""

    # Get auto-detected LAN bridge if enabled
    if [ "$AUTO_DETECT_LAN" = "true" ]; then
        # The get_lan_interface function already logs what it finds.
        auto_detected_list=$(get_lan_interface)
    fi

    # Get user-selected interfaces and log them clearly
    if [ -n "$INCLUDED_INTERFACES" ]; then
        # Clean up comma-separated list into a space-separated one
        user_selected_list=$(echo "$INCLUDED_INTERFACES" | tr ',' ' ' | tr -s ' ' | xargs)
        if [ -n "$user_selected_list" ]; then
            msg "User-selected included interfaces: $user_selected_list"
        fi
    fi

    # Combine, de-duplicate, and return the final list
    combined_list="$auto_detected_list $user_selected_list"

    if [ -z "$combined_list" ]; then
        msg "ERROR: No interfaces specified for explicit mode"
        return 1
    fi

    # Return a clean, unique, newline-separated list
    echo "$combined_list" | tr ' ' '\n' | grep -v '^$' | sort -u
}

# Function to get all interfaces to exclude (exclude mode) - with deduplication and clear logging
get_excluded_interfaces() {
    local auto_detected_list=""
    local user_selected_list=""
    local combined_list=""

    # Get auto-detected WAN interface if enabled
    if [ "$AUTO_DETECT_WAN" = "true" ]; then
        # The get_wan_interface function already logs what it finds.
        auto_detected_list=$(get_wan_interface)
    fi

    # Get user-selected interfaces and log them clearly
    if [ -n "$EXCLUDED_INTERFACES" ]; then
        # Clean up comma-separated list into a space-separated one
        user_selected_list=$(echo "$EXCLUDED_INTERFACES" | tr ',' ' ' | tr -s ' ' | xargs)
        if [ -n "$user_selected_list" ]; then
            msg "User-selected excluded interfaces: $user_selected_list"
        fi
    fi

    # Combine, de-duplicate, and return the final list
    combined_list="$auto_detected_list $user_selected_list"

    # Return a clean, unique, newline-separated list
    echo "$combined_list" | tr ' ' '\n' | grep -v '^$' | sort -u
}

# For nftables - apply interface exclusion rules in mangle chain
apply_nft_interface_exclusion_mangle() {
    local excluded_interfaces="$1"
    if [ -n "$excluded_interfaces" ]; then
        msg "Excluded interfaces in mangle: $(echo "$excluded_interfaces" | tr '\n' ' ')"
        echo "$excluded_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && nft add rule inet clash mangle iifname "$iface" return
        done
    fi
}

# For nftables - apply explicit interface rules in mangle chain
apply_nft_explicit_interface_mangle() {
    local included_interfaces
    included_interfaces=$(get_included_interfaces) || return 1

    if [ -n "$included_interfaces" ]; then
        msg "Processing traffic from interfaces: $(echo "$included_interfaces" | tr '\n' ' ')"
        echo "$included_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && nft add rule inet clash mangle iifname "$iface" jump CLASH_MARK
        done
    else
        return 1
    fi
}

# For nftables - apply DHCP exclusion rules in mangle chain
apply_nft_dhcp_mangle() {
    # Exclude DHCP traffic (ports 67-68)
    nft add rule inet clash CLASH_MARK udp sport 67 udp dport 68 return
    nft add rule inet clash CLASH_MARK udp sport 68 udp dport 67 return
    msg "DHCP traffic excluded from proxy in mangle"
}

# For nftables - prevent routing loops with marks in mangle chain
apply_nft_loop_prevention_mangle() {
    # Exclude packets already marked by Clash
    nft add rule inet clash CLASH_MARK meta mark 0x0002 return
    nft add rule inet clash CLASH_MARK meta mark and 0xff00 != 0 return
    msg "Loop prevention rules applied in mangle"
}

# For nftables - apply rules for reserved networks in mangle chain
apply_nft_reserved_networks_mangle() {
    for network in $RESERVED_NETWORKS; do
        nft add rule inet clash CLASH_MARK ip daddr "$network" return
    done
    msg "Reserved networks excluded from proxy in mangle"
}

# For nftables - block QUIC traffic in mangle chain
apply_nft_quic_blocking_mangle() {
    if [ "$BLOCK_QUIC" = "true" ]; then
        # Block QUIC traffic (UDP port 443) for improved proxy effectiveness
        nft add rule inet clash CLASH_MARK udp dport 443 reject
        msg "QUIC traffic blocked in mangle"
    else
        msg "QUIC blocking disabled"
    fi
}

# For nftables - exclude Clash process and ports in mangle chain
apply_nft_clash_exclusions_mangle() {
    # Exclude specific ports used by Clash
    nft add rule inet clash CLASH_MARK tcp dport {7890, 7891, 7892, 7893, 7894} return
    nft add rule inet clash CLASH_MARK udp dport {7890, 7891, 7892, 7893, 7894} return
    msg "Clash ports excluded from proxy in mangle"
}

# For nftables - exclude proxy server IPs in mangle chain
apply_nft_server_exclusions_mangle() {
    local server_ips="$1"
    if [ -n "$server_ips" ]; then
        echo "$server_ips" | while IFS= read -r ip; do
            [ -n "$ip" ] && nft add rule inet clash CLASH_MARK ip daddr "$ip/32" return
        done
        msg "Proxy server IPs excluded from proxy in mangle"
    else
        msg "No proxy server IPs to exclude"
    fi
}

# For nftables - apply fake-ip or global marking in mangle chain
apply_nft_marking_mangle() {
    local fake_ip_range="$1"
    if [ -n "$fake_ip_range" ]; then
        # Mark packets destined for fake-ip range
        nft add rule inet clash CLASH_MARK ip daddr "$fake_ip_range" meta l4proto tcp meta mark set 0x0001 counter
        nft add rule inet clash CLASH_MARK ip daddr "$fake_ip_range" meta l4proto udp meta mark set 0x0001 counter
        msg "Marking applied only for fake-ip range: $fake_ip_range"
    else
        # Mark all remaining traffic
        nft add rule inet clash CLASH_MARK meta l4proto tcp meta mark set 0x0001 counter
        nft add rule inet clash CLASH_MARK meta l4proto udp meta mark set 0x0001 counter
        msg "Marking applied for all traffic"
    fi
}

# For nftables - apply TPROXY rules in proxy chain
apply_nft_tproxy_proxy() {
    # Apply TPROXY to marked packets
    nft add rule inet clash proxy meta mark 0x0001 meta l4proto tcp tproxy ip to 127.0.0.1:7894 counter
    nft add rule inet clash proxy meta mark 0x0001 meta l4proto udp tproxy ip to 127.0.0.1:7894 counter
    msg "TPROXY rules applied in proxy chain"
}

# For nftables - apply interface exclusion rules in output chain
apply_nft_interface_exclusion_output() {
    local excluded_interfaces="$1"
    if [ -n "$excluded_interfaces" ]; then
        msg "Excluded interfaces in output: $(echo "$excluded_interfaces" | tr '\n' ' ')"
        echo "$excluded_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && nft add rule inet clash output oifname "$iface" return
        done
    fi
}

# For nftables - exclude Clash process and ports in output chain
apply_nft_clash_exclusions_output() {
    # Exclude Clash process itself (by user ID if available)
    nft add rule inet clash output meta skuid 0 return
    # Exclude specific ports used by Clash
    nft add rule inet clash output tcp sport {7890, 7891, 7892, 7893, 7894} return
    nft add rule inet clash output udp sport {7890, 7891, 7892, 7893, 7894} return
    msg "Clash process and ports excluded from proxy in output"
}

# For nftables - apply output chain rules
apply_nft_output_rules() {
    local server_ips="$1"
    local excluded_interfaces="$2"
    local fake_ip_filter_mode="$3"

    # Apply interface exclusions for output traffic
    apply_nft_interface_exclusion_output "$excluded_interfaces"
    # Exclude already marked packets
    nft add rule inet clash output meta mark 0x0002 return
    nft add rule inet clash output meta mark and 0xff00 != 0 return

    # Skip exclusion rules in whitelist mode
    if [ "$fake_ip_filter_mode" != "whitelist" ]; then
        # Exclude DHCP traffic
        nft add rule inet clash output udp sport 67 udp dport 68 return
        nft add rule inet clash output udp sport 68 udp dport 67 return
        # Apply exclusions for reserved networks
        for network in $RESERVED_NETWORKS; do
            nft add rule inet clash output ip daddr "$network" return
            nft add rule inet clash output ip saddr "$network" return
        done
        # Apply server exclusions if provided
        if [ -n "$server_ips" ]; then
            echo "$server_ips" | while IFS= read -r ip; do
                [ -n "$ip" ] && nft add rule inet clash output ip saddr "$ip/32" return && nft add rule inet clash output ip daddr "$ip/32" return
            done
        fi
    fi

    # Apply Clash exclusions
    apply_nft_clash_exclusions_output
    # Mark packets for routing
    nft add rule inet clash output meta mark 0 meta l4proto tcp meta mark set 0x0001
    nft add rule inet clash output meta mark 0 meta l4proto udp meta mark set 0x0001
    msg "Output chain rules applied"
}

# For iptables - apply explicit interface rules
apply_iptables_explicit_interface_rules() {
    local included_interfaces
    included_interfaces=$(get_included_interfaces) || return 1
    if [ -n "$included_interfaces" ]; then
        msg "Processing traffic from interfaces: $(echo "$included_interfaces" | tr '\n' ' ')"
        echo "$included_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && iptables -t mangle -A CLASH -i "$iface" -j CLASH_PROCESS
        done
    else
        return 1
    fi
}

# For iptables - apply exclude interface rules to prevent routing loops
apply_iptables_exclude_interface_rules() {
    local excluded_interfaces="$1"
    if [ -n "$excluded_interfaces" ]; then
        msg "Excluded interfaces: $(echo "$excluded_interfaces" | tr '\n' ' ')"
        echo "$excluded_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && iptables -t mangle -A CLASH -i "$iface" -j RETURN
        done
    else
        msg "No excluded interfaces found"
    fi
}

# For iptables - apply DHCP exclusion rules
apply_iptables_dhcp_rules() {
    if chain_exists "mangle" "CLASH_PROCESS"; then
        iptables -t mangle -I CLASH_PROCESS 1 -p udp --sport 67 --dport 68 -j RETURN
        iptables -t mangle -I CLASH_PROCESS 1 -p udp --sport 68 --dport 67 -j RETURN
        msg "DHCP traffic excluded from proxy"
    fi
}

# For iptables - prevent routing loops with marks
apply_iptables_loop_prevention() {
    iptables -t mangle -A CLASH_PROCESS -m mark --mark 0x0002 -j RETURN
    iptables -t mangle -A CLASH_PROCESS -m mark --mark 0xff00/0xff00 -j RETURN
    msg "Loop prevention rules applied"
}

# For iptables - apply rules for reserved networks
apply_iptables_reserved_networks() {
    for network in $RESERVED_NETWORKS; do
        iptables -t mangle -A CLASH_PROCESS -d "$network" -j RETURN
        iptables -t mangle -A CLASH_PROCESS -s "$network" -j RETURN
    done
    msg "Reserved networks excluded from proxy (both source and destination)"
}

# For iptables - block QUIC traffic
apply_iptables_quic_blocking() {
    if [ "$BLOCK_QUIC" = "true" ]; then
        iptables -t filter -I INPUT -p udp --dport 443 -j REJECT 2>/dev/null
        iptables -t filter -I FORWARD -p udp --dport 443 -j REJECT 2>/dev/null
        msg "QUIC traffic blocked"
    else
        msg "QUIC blocking disabled"
    fi
}

# For iptables - exclude Clash ports
apply_iptables_clash_exclusions() {
    iptables -t mangle -A CLASH_PROCESS -p tcp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_PROCESS -p udp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_PROCESS -p tcp --sport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_PROCESS -p udp --sport 7890:7894 -j RETURN
    msg "Clash ports excluded from proxy"
}

# For iptables - exclude proxy server IPs
apply_iptables_server_exclusions() {
    local server_ips="$1"
    if [ -n "$server_ips" ]; then
        echo "$server_ips" | while IFS= read -r ip; do
            [ -n "$ip" ] && {
                iptables -t mangle -A CLASH_PROCESS -d "$ip/32" -j RETURN
                iptables -t mangle -A CLASH_PROCESS -s "$ip/32" -j RETURN
            }
        done
        msg "Proxy server IPs excluded from proxy"
    else
        msg "No proxy server IPs to exclude"
    fi
}

# For iptables - apply TPROXY rules
apply_iptables_tproxy_rules() {
    local fake_ip_range="$1"
    if [ -n "$fake_ip_range" ]; then
        iptables -t mangle -A CLASH_PROCESS -d "$fake_ip_range" -p tcp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        iptables -t mangle -A CLASH_PROCESS -d "$fake_ip_range" -p udp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        msg "TPROXY rules applied only for fake-ip range: $fake_ip_range"
    else
        iptables -t mangle -A CLASH_PROCESS -p tcp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        iptables -t mangle -A CLASH_PROCESS -p udp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        msg "TPROXY rules applied for all traffic"
    fi
}

# For iptables - apply interface exclusion rules in output chain
apply_iptables_interface_exclusion_output() {
    local excluded_interfaces="$1"
    if [ -n "$excluded_interfaces" ]; then
        msg "Excluded interfaces in output (iptables): $(echo "$excluded_interfaces" | tr '\n' ' ')"
        echo "$excluded_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && iptables -t mangle -I CLASH_LOCAL 1 -o "$iface" -j RETURN
        done
    fi
}

# For iptables - apply output chain rules
apply_iptables_output_rules() {
    local server_ips="$1"
    local excluded_interfaces="$2"
    local fake_ip_filter_mode="$3"

    # Apply interface exclusions for output traffic
    apply_iptables_interface_exclusion_output "$excluded_interfaces"
    # Exclude already marked packets
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0x0002 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0xff00/0xff00 -j RETURN

    # Skip exclusion rules in whitelist mode
    if [ "$fake_ip_filter_mode" != "whitelist" ]; then
        # Exclude DHCP traffic
        iptables -t mangle -I CLASH_LOCAL 1 -p udp --sport 67 --dport 68 -j RETURN
        iptables -t mangle -I CLASH_LOCAL 1 -p udp --sport 68 --dport 67 -j RETURN
        # Apply exclusions for reserved networks
        for network in $RESERVED_NETWORKS; do
            iptables -t mangle -A CLASH_LOCAL -d "$network" -j RETURN
            iptables -t mangle -A CLASH_LOCAL -s "$network" -j RETURN
        done
        # Apply server exclusions if provided
        if [ -n "$server_ips" ]; then
            echo "$server_ips" | while IFS= read -r ip; do
                [ -n "$ip" ] && {
                    iptables -t mangle -A CLASH_LOCAL -d "$ip/32" -j RETURN
                    iptables -t mangle -A CLASH_LOCAL -s "$ip/32" -j RETURN
                }
            done
        fi
    fi

    # Exclude Clash process and ports
    iptables -t mangle -A CLASH_LOCAL -p tcp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -p udp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -p tcp --sport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -p udp --sport 7890:7894 -j RETURN

    # Mark packets for routing (only unmarked packets)
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0 -p tcp -j MARK --set-mark 0x0001
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0 -p udp -j MARK --set-mark 0x0001

    msg "Output chain rules applied"
}

# Apply nftables rules dynamically
apply_nft_rules() {
    local server_ips="$1"
    local fake_ip_range="$2"
    local fake_ip_filter_mode="$3"

    nft delete table inet clash 2>/dev/null

    # Create table and chains with two-stage approach and proper priority ordering:
    # Stage 1: Mangle chain (priority -150) - interface filtering, exclusions, and packet marking
    # Stage 2: Proxy chain (priority -100) - TPROXY redirection for marked packets
    # Output chain (priority mangle) - handle locally generated traffic
    nft add table inet clash
    nft add chain inet clash mangle '{ type filter hook prerouting priority -150; policy accept; }'
    nft add chain inet clash proxy '{ type filter hook prerouting priority -100; policy accept; }'
    nft add chain inet clash output '{ type route hook output priority mangle; policy accept; }'
    nft add chain inet clash CLASH_MARK

    case "$MODE" in
        "explicit")
            apply_nft_explicit_interface_mangle || return 1
            ;;
        *) # exclude mode
            local excluded_interfaces=$(get_excluded_interfaces)
            apply_nft_interface_exclusion_mangle "$excluded_interfaces"
            nft add rule inet clash mangle jump CLASH_MARK
            # In exclude mode, we also need to process locally generated traffic
            apply_nft_output_rules "$server_ips" "$excluded_interfaces" "$fake_ip_filter_mode"
            msg "nftables output rules applied (exclude mode)"
            ;;
    esac

    # Apply common exclusion and marking rules
    apply_nft_loop_prevention_mangle
    apply_nft_clash_exclusions_mangle
    apply_nft_quic_blocking_mangle

    # Skip exclusion rules in whitelist mode
    if [ "$fake_ip_filter_mode" != "whitelist" ]; then
        apply_nft_dhcp_mangle
        apply_nft_reserved_networks_mangle
        apply_nft_server_exclusions_mangle "$server_ips"
        msg "Full exclusion rules applied"
    else
        msg "Minimal exclusion rules applied (fake-ip-filter-mode: whitelist - only system protection)"
    fi

    apply_nft_marking_mangle "$fake_ip_range"

    # Apply TPROXY rules
    apply_nft_tproxy_proxy

    msg "nftables rules applied successfully"
}

# Apply iptables rules dynamically
apply_iptables_rules() {
    local server_ips="$1"
    local fake_ip_range="$2"
    local fake_ip_filter_mode="$3"

    # Create all chains first before applying any rules
    iptables -t mangle -N CLASH 2>/dev/null
    iptables -t mangle -N CLASH_LOCAL 2>/dev/null
    iptables -t mangle -N CLASH_PROCESS 2>/dev/null

    # Apply rules based on the operation mode
    case "$MODE" in
        "explicit")
            apply_iptables_explicit_interface_rules || return 1
            ;;
        *) # exclude mode
            local excluded_interfaces=$(get_excluded_interfaces)
            apply_iptables_exclude_interface_rules "$excluded_interfaces"
            iptables -t mangle -A CLASH -j CLASH_PROCESS
            # In exclude mode, we also need to process locally generated traffic
            apply_iptables_output_rules "$server_ips" "$excluded_interfaces" "$fake_ip_filter_mode"
            msg "iptables output rules applied (exclude mode)"
            ;;
    esac

    # Apply common exclusion and marking rules
    apply_iptables_loop_prevention
    apply_iptables_clash_exclusions
    apply_iptables_quic_blocking

    # Skip exclusion rules in whitelist mode
    if [ "$fake_ip_filter_mode" != "whitelist" ]; then
        apply_iptables_dhcp_rules
        apply_iptables_reserved_networks
        apply_iptables_server_exclusions "$server_ips"
        msg "Full exclusion rules applied"
    else
        msg "Minimal exclusion rules applied (fake-ip-filter-mode: whitelist - only system protection)"
    fi

    apply_iptables_tproxy_rules "$fake_ip_range"

    # Hook the main chains into the system. This is the entry point.
    iptables -t mangle -A PREROUTING -j CLASH

    if [ "$MODE" != "explicit" ]; then
        iptables -t mangle -A OUTPUT -j CLASH_LOCAL
        msg "iptables rules applied successfully (exclude mode with output processing)"
    else
        msg "iptables rules applied successfully (explicit mode without output processing)"
    fi
}

start() {
    msg "Starting Clash rules script"
    # Load all settings once from the file
    load_all_settings_once

    local server_ips fake_ip_config fake_ip_range fake_ip_filter_mode
    server_ips=$(extract_server_ips)
    fake_ip_config=$(extract_fake_ip_config)

    # Parse the combined result
    if [ -n "$fake_ip_config" ]; then
        fake_ip_range="${fake_ip_config%|*}"
        fake_ip_filter_mode="${fake_ip_config#*|}"
    fi

    if [ -n "$server_ips" ]; then
        msg "Extracted server IPs: $(echo "$server_ips" | tr '\n' ' ')"
    else
        msg "WARNING: No server IPs extracted from config"
    fi

    if [ -n "$fake_ip_range" ]; then
        if [ "$fake_ip_filter_mode" = "whitelist" ]; then
            msg "Detected fake-ip range: $fake_ip_range with whitelist mode (most exclusion rules will be skipped) - TPROXY will be applied only to this range"
        else
            msg "Detected fake-ip range: $fake_ip_range with blacklist mode - TPROXY will be applied only to this range"
        fi
    else
        msg "No fake-ip configuration detected - TPROXY will be applied to all traffic"
    fi

    if hash nft 2>/dev/null; then
        msg "Using nftables for traffic redirection"
        if apply_nft_rules "$server_ips" "$fake_ip_range" "$fake_ip_filter_mode"; then
            ip route add local default dev lo table 100 2>/dev/null
            ip rule add fwmark 0x0001 table 100 2>/dev/null
        else
            msg "ERROR: Failed to apply nftables rules"
            return 1
        fi
    elif hash iptables 2>/dev/null; then
        msg "Using iptables for traffic redirection"
        if apply_iptables_rules "$server_ips" "$fake_ip_range" "$fake_ip_filter_mode"; then
            ip route add local default dev lo table 100 2>/dev/null
            ip rule add fwmark 0x0001 table 100 2>/dev/null
        else
            msg "ERROR: Failed to apply iptables rules"
            return 1
        fi
    else
        msg "ERROR: Neither nftables nor iptables found"
        return 1
    fi

    msg "Clash rules script started successfully"
}

stop() {
    msg "Stopping Clash rules script"
    # Load settings to know if QUIC rules need to be removed
    load_all_settings_once

    if hash nft 2>/dev/null; then
        nft delete table inet clash 2>/dev/null
        ip route del local default dev lo table 100 2>/dev/null
        ip rule del fwmark 0x0001 table 100 2>/dev/null
        msg "nftables rules removed successfully"
    elif hash iptables 2>/dev/null; then
        if [ "$BLOCK_QUIC" = "true" ]; then
            iptables -t filter -D INPUT -p udp --dport 443 -j REJECT 2>/dev/null
            iptables -t filter -D FORWARD -p udp --dport 443 -j REJECT 2>/dev/null
        fi

        iptables -t mangle -D PREROUTING -j CLASH 2>/dev/null
        iptables -t mangle -F CLASH 2>/dev/null
        iptables -t mangle -X CLASH 2>/dev/null
        iptables -t mangle -F CLASH_PROCESS 2>/dev/null
        iptables -t mangle -X CLASH_PROCESS 2>/dev/null
        iptables -t mangle -D OUTPUT -j CLASH_LOCAL 2>/dev/null
        iptables -t mangle -F CLASH_LOCAL 2>/dev/null
        iptables -t mangle -X CLASH_LOCAL 2>/dev/null
        ip route del local default dev lo table 100 2>/dev/null
        ip rule del fwmark 0x0001 table 100 2>/dev/null
        msg "iptables rules removed successfully"
    else
        msg "ERROR: Neither nftables nor iptables found"
        return 1
    fi

    msg "Clash rules script stopped successfully"
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    *)
        echo "Usage: $0 {start|stop}"
        exit 1
        ;;
esac

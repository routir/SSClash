#!/bin/sh

CONFIG_FILE="/opt/clash/config.yaml"
EXCLUDED_INTERFACES_FILE="/opt/clash/excluded_interfaces"
INCLUDED_INTERFACES_FILE="/opt/clash/included_interfaces"
SETTINGS_FILE="/opt/clash/settings"

readonly RESERVED_NETWORKS="0.0.0.0/8 10.0.0.0/8 100.64.0.0/10 127.0.0.0/8 169.254.0.0/16 172.16.0.0/12 192.0.2.0/24 192.88.99.0/24 192.168.0.0/16 198.51.100.0/24 203.0.113.0/24 224.0.0.0/4 240.0.0.0/4 255.255.255.255/32"

# Function to log messages
msg() {
    logger -p daemon.info -st "clash-rules[$$]" "$*"
}

# Function to extract fake-ip range from config.yaml
extract_fake_ip_range() {
    if [ ! -f "$CONFIG_FILE" ]; then
        return 1
    fi

    # Use awk to parse DNS section
    local dns_settings=$(awk '
    /^dns:/ { in_dns = 1; next }
    /^[a-zA-Z]/ && !/^  / { in_dns = 0 }
    in_dns && /enable:/ {
        gsub(/^[[:space:]]*enable:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        if ($0 == "true") enable = "true"
    }
    in_dns && /enhanced-mode:/ {
        gsub(/^[[:space:]]*enhanced-mode:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        if ($0 == "fake-ip") mode = "fake-ip"
    }
    in_dns && /fake-ip-range:/ {
        gsub(/^[[:space:]]*fake-ip-range:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        range = $0
    }
    END {
        if (enable == "true" && mode == "fake-ip" && range != "") {
            print range
        }
    }
    ' "$CONFIG_FILE")

    if [ -n "$dns_settings" ]; then
        echo "$dns_settings"
        return 0
    fi

    return 1
}

# Function to load settings
load_settings() {
    local mode="exclude"
    local auto_detect_lan="true"
    local auto_detect_wan="true"
    local block_quic="true"

    if [ -f "$SETTINGS_FILE" ]; then
        while IFS='=' read -r key value; do
            case "$key" in
                "INTERFACE_MODE") mode="$value" ;;
                "AUTO_DETECT_LAN") auto_detect_lan="$value" ;;
                "AUTO_DETECT_WAN") auto_detect_wan="$value" ;;
                "BLOCK_QUIC") block_quic="$value" ;;
            esac
        done < "$SETTINGS_FILE"
    fi

    echo "${mode}:${auto_detect_lan}:${auto_detect_wan}:${block_quic}"
}

# Function to auto-detect LAN bridge interface with VLAN support
auto_detect_lan_bridge() {
    local bridge=""

    # Search for bridge interfaces with active ports and private IP ranges
    for br in $(ls /sys/class/net/ 2>/dev/null | grep -E '^br-|^bridge'); do
        if [ -d "/sys/class/net/$br/brif" ] && [ -n "$(ls /sys/class/net/$br/brif/ 2>/dev/null)" ]; then
            local ip=$(ip addr show "$br" 2>/dev/null | awk '/inet / {print $2}' | head -1)
            if [ -n "$ip" ]; then
                case "$ip" in
                    192.168.*|10.*|172.1[6-9].*|172.2[0-9].*|172.3[0-1].*)
                        bridge="$br"
                        break
                        ;;
                esac
            fi
        fi
    done

    # If no bridge with ports found, look for bridges with IP addresses (including VLANs)
    if [ -z "$bridge" ]; then
        for br in $(ls /sys/class/net/ 2>/dev/null | grep -E '^br-'); do
            local ip=$(ip addr show "$br" 2>/dev/null | awk '/inet / {print $2}' | head -1)
            if [ -n "$ip" ]; then
                case "$ip" in
                    192.168.*|10.*|172.1[6-9].*|172.2[0-9].*|172.3[0-1].*)
                        bridge="$br"
                        break
                        ;;
                esac
            fi
        done
    fi

    echo "$bridge"
}

# Function to get interfaces for processing (explicit mode)
get_included_interfaces() {
    local settings auto_detect_lan included_interfaces lan_bridge

    settings=$(load_settings)
    auto_detect_lan=$(echo "$settings" | cut -d: -f2)

    # Auto-detect LAN bridge if enabled
    if [ "$auto_detect_lan" = "true" ]; then
        lan_bridge=$(auto_detect_lan_bridge)
        if [ -n "$lan_bridge" ]; then
            msg "Auto-detected LAN bridge: $lan_bridge"
            echo "$lan_bridge"
            return
        fi
    fi

    # Load manually selected interfaces
    if [ -f "$INCLUDED_INTERFACES_FILE" ]; then
        included_interfaces=$(cat "$INCLUDED_INTERFACES_FILE" | grep -v '^$' | sort -u)
        if [ -n "$included_interfaces" ]; then
            msg "User-selected included interfaces: $(echo "$included_interfaces" | tr '\n' ' ')"
            echo "$included_interfaces"
            return
        fi
    fi

    msg "No interfaces configured for explicit mode"
    return
}

# Function to check if a string is a valid IP address
is_valid_ip() {
    local ip="$1"
    # Check if it's a valid IPv4 address
    echo "$ip" | grep -qE '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
}

# Function to resolve domain name to IP addresses
resolve_domain() {
    local domain="$1"
    local resolved_ips=""

    # Use nslookup to resolve the domain
    if command -v nslookup >/dev/null 2>&1; then
        resolved_ips=$(nslookup "$domain" 2>/dev/null | awk '/^Address: / { print $2 }' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')
    fi

    # If nslookup failed or not available, try using getent
    if [ -z "$resolved_ips" ] && command -v getent >/dev/null 2>&1; then
        resolved_ips=$(getent hosts "$domain" 2>/dev/null | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')
    fi

    # If getent failed or not available, try using wget
    if [ -z "$resolved_ips" ] && command -v wget >/dev/null 2>&1; then
        resolved_ips=$(wget -T 5 -t 1 --spider "$domain" 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')
    fi

    # If all failed, try using ping (fallback)
    if [ -z "$resolved_ips" ] && command -v ping >/dev/null 2>&1; then
        resolved_ips=$(ping -c 1 -W 2 "$domain" 2>/dev/null | head -1 | grep -oE '\([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\)' | tr -d '()')
    fi

    # Ensure each IP is on a separate line and remove duplicates
    if [ -n "$resolved_ips" ]; then
        echo "$resolved_ips" | tr ' ' '\n' | grep -v '^$' | sort -u
    fi
}

# Extract server IPs from config.yaml
extract_server_ips() {
    if [ ! -f "$CONFIG_FILE" ]; then
        msg "ERROR: Config file not found: $CONFIG_FILE"
        return 1
    fi

    # Extract servers using awk
    local servers=$(awk '
    /^proxies:/ { in_proxies = 1; next }
    /^[a-zA-Z]/ && !/^  / { in_proxies = 0 }
    in_proxies && /server:/ {
        gsub(/^[[:space:]]*server:[[:space:]]*/, "")
        gsub(/[[:space:]]*$/, "")
        sub(/#.*/, "")
        if ($0 != "") print $0
    }
    ' "$CONFIG_FILE")

    # Process each server entry
    if [ -n "$servers" ]; then
        echo "$servers" | while IFS= read -r server; do
            [ -z "$server" ] && continue

            if is_valid_ip "$server"; then
                # It's already an IP address
                echo "$server"
            else
                # It's a domain name, resolve it
                resolved_ips=$(resolve_domain "$server")
                if [ -n "$resolved_ips" ]; then
                    echo "$resolved_ips"
                else
                    msg "WARNING: Could not resolve domain: $server"
                fi
            fi
        done
    fi
}

# Function to get WAN interface through which default route passes
get_wan_interface() {
    local wan_interface=""

    # Get the interface through which default route passes
    wan_interface=$(ip route show default 2>/dev/null | awk '/default via/ {print $5}' | head -1)

    # Fallback to route table lookup
    if [ -z "$wan_interface" ]; then
        wan_interface=$(awk '$2 == "00000000" { print $1; exit }' /proc/net/route 2>/dev/null)
    fi

    # Try UCI configuration if available
    if [ -z "$wan_interface" ] && command -v uci >/dev/null 2>&1; then
        wan_interface=$(uci get network.wan.device 2>/dev/null || uci get network.wan.ifname 2>/dev/null)
    fi

    # Final fallback using netstat
    if [ -z "$wan_interface" ]; then
        wan_interface=$(netstat -rn 2>/dev/null | awk '/^0\.0\.0\.0/ {print $NF; exit}')
    fi

    echo "$wan_interface"
}

# Function to ensure WAN interface is saved in excluded_interfaces file
ensure_wan_excluded() {
    local settings auto_detect_wan wan_interface

    settings=$(load_settings)
    auto_detect_wan=$(echo "$settings" | cut -d: -f3)

    # Skip if auto-detection is disabled
    if [ "$auto_detect_wan" = "false" ]; then
        return
    fi

    wan_interface=$(get_wan_interface)
    [ -z "$wan_interface" ] && return

    # Create file if it doesn't exist
    touch "$EXCLUDED_INTERFACES_FILE" 2>/dev/null

    # Check if already exists
    if grep -q "^${wan_interface}$" "$EXCLUDED_INTERFACES_FILE" 2>/dev/null; then
        return
    fi

    # Add WAN interface to excluded list and log
    echo "$wan_interface" >> "$EXCLUDED_INTERFACES_FILE"
    msg "Adding WAN interface '$wan_interface' to excluded interfaces file"
}

# Function to load excluded interfaces from config file
load_excluded_interfaces() {
    if [ -f "$EXCLUDED_INTERFACES_FILE" ]; then
        cat "$EXCLUDED_INTERFACES_FILE" | grep -v '^$' | sort -u
    fi
}

# Function to get all interfaces to exclude (WAN + user-selected)
get_excluded_interfaces() {
    local settings auto_detect_wan wan_interface excluded_interfaces user_only all_excluded=""

    settings=$(load_settings)
    auto_detect_wan=$(echo "$settings" | cut -d: -f3)

    # Add auto-detected WAN interface if enabled
    if [ "$auto_detect_wan" = "true" ]; then
        wan_interface=$(get_wan_interface)
        if [ -n "$wan_interface" ]; then
            all_excluded="$wan_interface"
            msg "Auto-detected WAN interface: $wan_interface"
        fi
    fi

    # Get user-selected excluded interfaces
    excluded_interfaces=$(load_excluded_interfaces)

    # Remove WAN from user list to avoid duplication in logs
    if [ "$auto_detect_wan" = "true" ] && [ -n "$wan_interface" ] && [ -n "$excluded_interfaces" ]; then
        user_only=$(echo "$excluded_interfaces" | grep -v "^${wan_interface}$")
    else
        user_only="$excluded_interfaces"
    fi

    # Combine auto-detected and user-selected interfaces
    if [ -n "$user_only" ]; then
        if [ -n "$all_excluded" ]; then
            all_excluded="$all_excluded
$user_only"
        else
            all_excluded="$user_only"
        fi
        msg "User-selected excluded interfaces: $(echo "$user_only" | tr '\n' ' ')"
    fi

    # Remove duplicates and return
    if [ -n "$all_excluded" ]; then
        echo "$all_excluded" | sort -u
    fi
}

# Function to check if chain exists (iptables only)
chain_exists() {
    local table="$1"
    local chain="$2"
    iptables -t "$table" -L "$chain" >/dev/null 2>&1
}

# For nftables - apply explicit interface rules
apply_nft_explicit_interface_rules() {
    local included_interfaces
    included_interfaces=$(get_included_interfaces)

    if [ -n "$included_interfaces" ]; then
        msg "Processing traffic from interfaces: $(echo "$included_interfaces" | tr '\n' ' ')"
        echo "$included_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && nft add rule ip clash prerouting iifname "$iface" jump CLASH_PROCESS
        done
    else
        msg "ERROR: No interfaces specified for explicit mode"
        return 1
    fi
}

# For nftables - apply exclude interface rules
apply_nft_exclude_interface_rules() {
    local excluded_interfaces
    excluded_interfaces=$(get_excluded_interfaces)

    if [ -n "$excluded_interfaces" ]; then
        msg "Excluded interfaces: $(echo "$excluded_interfaces" | tr '\n' ' ')"
        echo "$excluded_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && nft add rule ip clash prerouting iifname "$iface" return
        done
    else
        msg "No excluded interfaces found"
    fi
}

# For iptables - apply explicit interface rules
apply_iptables_explicit_interface_rules() {
    local included_interfaces
    included_interfaces=$(get_included_interfaces)

    if [ -n "$included_interfaces" ]; then
        msg "Processing traffic from interfaces: $(echo "$included_interfaces" | tr '\n' ' ')"
        echo "$included_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && iptables -t mangle -A CLASH -i "$iface" -j CLASH_PROCESS
        done
    else
        msg "ERROR: No interfaces specified for explicit mode"
        return 1
    fi
}

# For iptables - apply exclude interface rules to prevent routing loops
apply_iptables_exclude_interface_rules() {
    local excluded_interfaces
    excluded_interfaces=$(get_excluded_interfaces)

    if [ -n "$excluded_interfaces" ]; then
        msg "Excluded interfaces: $(echo "$excluded_interfaces" | tr '\n' ' ')"
        echo "$excluded_interfaces" | while IFS= read -r iface; do
            [ -n "$iface" ] && iptables -t mangle -A CLASH -i "$iface" -j RETURN
        done
    else
        msg "No excluded interfaces found"
    fi
}

# For nftables - apply DHCP exclusion rules
apply_nft_dhcp_rules() {
    # Exclude DHCP traffic (ports 67-68)
    nft add rule ip clash CLASH_PROCESS udp sport 67 udp dport 68 return
    nft add rule ip clash CLASH_PROCESS udp sport 68 udp dport 67 return
    nft add rule ip clash output udp sport 67 udp dport 68 return
    nft add rule ip clash output udp sport 68 udp dport 67 return

    msg "DHCP traffic excluded from proxy"
}

# For iptables - apply DHCP exclusion rules
apply_iptables_dhcp_rules() {
    # Exclude DHCP traffic (ports 67-68) - only if chains exist
    if chain_exists "mangle" "CLASH_PROCESS"; then
        iptables -t mangle -I CLASH_PROCESS 1 -p udp --sport 67 --dport 68 -j RETURN
        iptables -t mangle -I CLASH_PROCESS 1 -p udp --sport 68 --dport 67 -j RETURN
    fi

    if chain_exists "mangle" "CLASH_LOCAL"; then
        iptables -t mangle -I CLASH_LOCAL 1 -p udp --sport 67 --dport 68 -j RETURN
        iptables -t mangle -I CLASH_LOCAL 1 -p udp --sport 68 --dport 67 -j RETURN
    fi

    msg "DHCP traffic excluded from proxy"
}

# For nftables - prevent routing loops with marks
apply_nft_loop_prevention() {
    # Exclude packets already marked by Clash
    nft add rule ip clash CLASH_PROCESS meta mark 0x0002 return
    nft add rule ip clash output meta mark 0x0002 return

    # Prevent already marked packets from re-entering
    nft add rule ip clash CLASH_PROCESS meta mark and 0xff00 != 0 return
    nft add rule ip clash output meta mark and 0xff00 != 0 return

    msg "Loop prevention rules applied"
}

# For iptables - prevent routing loops with marks
apply_iptables_loop_prevention() {
    # Exclude packets already marked by Clash
    iptables -t mangle -A CLASH_PROCESS -m mark --mark 0x0002 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0x0002 -j RETURN

    # Prevent already marked packets
    iptables -t mangle -A CLASH_PROCESS -m mark --mark 0xff00/0xff00 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0xff00/0xff00 -j RETURN

    msg "Loop prevention rules applied"
}

# For nftables - apply rules for reserved networks
apply_nft_reserved_networks() {
    for network in $RESERVED_NETWORKS; do
        nft add rule ip clash CLASH_PROCESS ip daddr "$network" return
        nft add rule ip clash output ip daddr "$network" return
    done

    msg "Reserved networks excluded from proxy"
}

# For iptables - apply rules for reserved networks
apply_iptables_reserved_networks() {
    for network in $RESERVED_NETWORKS; do
        iptables -t mangle -A CLASH_PROCESS -d "$network" -j RETURN
        iptables -t mangle -A CLASH_PROCESS -s "$network" -j RETURN
        iptables -t mangle -A CLASH_LOCAL -d "$network" -j RETURN
        iptables -t mangle -A CLASH_LOCAL -s "$network" -j RETURN
    done

    msg "Reserved networks excluded from proxy (both source and destination)"
}

# For nftables - block QUIC traffic
apply_nft_quic_blocking() {
    local settings block_quic

    settings=$(load_settings)
    block_quic=$(echo "$settings" | cut -d: -f4)

    if [ "$block_quic" = "true" ]; then
        # Block QUIC traffic (UDP port 443) for improved proxy effectiveness
        nft add rule ip clash CLASH_PROCESS udp dport 443 reject
        msg "QUIC traffic blocked"
    else
        msg "QUIC blocking disabled"
    fi
}

# For iptables - block QUIC traffic
apply_iptables_quic_blocking() {
    local settings block_quic

    settings=$(load_settings)
    block_quic=$(echo "$settings" | cut -d: -f4)

    if [ "$block_quic" = "true" ]; then
        # Block QUIC traffic (UDP port 443) for improved proxy effectiveness
        iptables -t filter -I INPUT -p udp --dport 443 -j REJECT 2>/dev/null
        iptables -t filter -I FORWARD -p udp --dport 443 -j REJECT 2>/dev/null
        msg "QUIC traffic blocked"
    else
        msg "QUIC blocking disabled"
    fi
}

# For nftables - exclude Clash process and ports
apply_nft_clash_exclusions() {
    # Exclude Clash process itself (by user ID if available)
    nft add rule ip clash output meta skuid 0 return

    # Exclude specific ports used by Clash
    nft add rule ip clash CLASH_PROCESS tcp dport {7890, 7891, 7892, 7893, 7894} return
    nft add rule ip clash CLASH_PROCESS udp dport {7890, 7891, 7892, 7893, 7894} return
    nft add rule ip clash output tcp sport {7890, 7891, 7892, 7893, 7894} return
    nft add rule ip clash output udp sport {7890, 7891, 7892, 7893, 7894} return

    msg "Clash process and ports excluded from proxy"
}

# For iptables - exclude Clash ports
apply_iptables_clash_exclusions() {
    # Exclude specific ports used by Clash
    iptables -t mangle -A CLASH_PROCESS -p tcp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_PROCESS -p udp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_PROCESS -p tcp --sport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_PROCESS -p udp --sport 7890:7894 -j RETURN

    iptables -t mangle -A CLASH_LOCAL -p tcp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -p udp --dport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -p tcp --sport 7890:7894 -j RETURN
    iptables -t mangle -A CLASH_LOCAL -p udp --sport 7890:7894 -j RETURN

    msg "Clash ports excluded from proxy"
}

# For nftables - exclude proxy server IPs
apply_nft_server_exclusions() {
    local server_ips="$1"

    if [ -n "$server_ips" ]; then
        echo "$server_ips" | while IFS= read -r ip; do
            [ -n "$ip" ] && {
                nft add rule ip clash CLASH_PROCESS ip saddr "$ip/32" return
                nft add rule ip clash CLASH_PROCESS ip daddr "$ip/32" return
                nft add rule ip clash output ip saddr "$ip/32" return
                nft add rule ip clash output ip daddr "$ip/32" return
            }
        done
        msg "Proxy server IPs excluded from proxy"
    else
        msg "No proxy server IPs to exclude"
    fi
}

# For iptables - exclude proxy server IPs
apply_iptables_server_exclusions() {
    local server_ips="$1"

    if [ -n "$server_ips" ]; then
        echo "$server_ips" | while IFS= read -r ip; do
            [ -n "$ip" ] && {
                iptables -t mangle -A CLASH_PROCESS -d "$ip/32" -j RETURN
                iptables -t mangle -A CLASH_PROCESS -s "$ip/32" -j RETURN
                iptables -t mangle -A CLASH_LOCAL -d "$ip/32" -j RETURN
                iptables -t mangle -A CLASH_LOCAL -s "$ip/32" -j RETURN
            }
        done
        msg "Proxy server IPs excluded from proxy"
    else
        msg "No proxy server IPs to exclude"
    fi
}

# For nftables - apply TPROXY rules
apply_nft_tproxy_rules() {
    local fake_ip_range="$1"

    if [ -n "$fake_ip_range" ]; then
        # TPROXY rules with mark to prevent loops - only for fake-ip range
        nft add rule ip clash CLASH_PROCESS ip daddr "$fake_ip_range" ip protocol tcp tproxy to 127.0.0.1:7894 meta mark set 0x0001
        nft add rule ip clash CLASH_PROCESS ip daddr "$fake_ip_range" ip protocol udp tproxy to 127.0.0.1:7894 meta mark set 0x0001
        msg "TPROXY rules applied only for fake-ip range: $fake_ip_range"
    else
        # TPROXY rules with mark to prevent loops - for all traffic
        nft add rule ip clash CLASH_PROCESS ip protocol tcp tproxy to 127.0.0.1:7894 meta mark set 0x0001
        nft add rule ip clash CLASH_PROCESS ip protocol udp tproxy to 127.0.0.1:7894 meta mark set 0x0001
        msg "TPROXY rules applied for all traffic"
    fi

    # Mark packets for routing (only unmarked packets)
    nft add rule ip clash output meta mark 0 ip protocol tcp meta mark set 0x0001
    nft add rule ip clash output meta mark 0 ip protocol udp meta mark set 0x0001
}

# For iptables - apply TPROXY rules
apply_iptables_tproxy_rules() {
    local fake_ip_range="$1"

    if [ -n "$fake_ip_range" ]; then
        # TPROXY rules with mark to prevent loops - only for fake-ip range
        iptables -t mangle -A CLASH_PROCESS -d "$fake_ip_range" -p tcp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        iptables -t mangle -A CLASH_PROCESS -d "$fake_ip_range" -p udp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        msg "TPROXY rules applied only for fake-ip range: $fake_ip_range"
    else
        # TPROXY rules with mark to prevent loops - for all traffic
        iptables -t mangle -A CLASH_PROCESS -p tcp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        iptables -t mangle -A CLASH_PROCESS -p udp -j TPROXY --on-ip 127.0.0.1 --on-port 7894 --tproxy-mark 0x0001
        msg "TPROXY rules applied for all traffic"
    fi

    # Mark packets for routing (only unmarked packets)
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0 -p tcp -j MARK --set-mark 0x0001
    iptables -t mangle -A CLASH_LOCAL -m mark --mark 0 -p udp -j MARK --set-mark 0x0001
}

# Apply nftables rules dynamically
apply_nft_rules() {
    local server_ips="$1"
    local fake_ip_range="$2"
    local settings mode

    settings=$(load_settings)
    mode=$(echo "$settings" | cut -d: -f1)

    # Delete existing table
    nft delete table ip clash 2>/dev/null

    # Create table and chains
    nft add table ip clash
    nft add chain ip clash prerouting '{ type filter hook prerouting priority dstnat + 10; policy accept; }'
    nft add chain ip clash output '{ type route hook output priority mangle; policy accept; }'

    # Create CLASH_PROCESS chain first before any references to it
    nft add chain ip clash CLASH_PROCESS

    # Apply interface rules based on mode
    case "$mode" in
        "explicit")
            if ! apply_nft_explicit_interface_rules; then
                msg "ERROR: Failed to apply explicit interface rules"
                return 1
            fi
            ;;
        "exclude"|*)
            apply_nft_exclude_interface_rules
            # Add jump to CLASH_PROCESS for exclude mode only
            nft add rule ip clash prerouting jump CLASH_PROCESS
            ;;
    esac

    # Apply rules in logical order
    apply_nft_dhcp_rules
    apply_nft_loop_prevention
    apply_nft_reserved_networks
    apply_nft_quic_blocking
    apply_nft_clash_exclusions
    apply_nft_server_exclusions "$server_ips"
    apply_nft_tproxy_rules "$fake_ip_range"

    msg "nftables rules applied successfully"
}

# Apply iptables rules dynamically
apply_iptables_rules() {
    local server_ips="$1"
    local fake_ip_range="$2"
    local settings mode

    settings=$(load_settings)
    mode=$(echo "$settings" | cut -d: -f1)

    # Create all chains first before applying any rules
    iptables -t mangle -N CLASH 2>/dev/null
    iptables -t mangle -N CLASH_LOCAL 2>/dev/null
    iptables -t mangle -N CLASH_PROCESS 2>/dev/null

    # Apply interface rules based on mode
    case "$mode" in
        "explicit")
            if ! apply_iptables_explicit_interface_rules; then
                msg "ERROR: Failed to apply explicit interface rules"
                return 1
            fi
            ;;
        "exclude"|*)
            apply_iptables_exclude_interface_rules
            # Add jump to CLASH_PROCESS for exclude mode only
            iptables -t mangle -A CLASH -j CLASH_PROCESS
            ;;
    esac

    # Apply rules in logical order
    apply_iptables_dhcp_rules
    apply_iptables_loop_prevention
    apply_iptables_reserved_networks
    apply_iptables_quic_blocking
    apply_iptables_clash_exclusions
    apply_iptables_server_exclusions "$server_ips"
    apply_iptables_tproxy_rules "$fake_ip_range"

    # Hook chains into main tables
    iptables -t mangle -A PREROUTING -j CLASH
    iptables -t mangle -A OUTPUT -j CLASH_LOCAL

    msg "iptables rules applied successfully"
}

start() {
    msg "Starting Clash rules script"

    local settings mode
    settings=$(load_settings)
    mode=$(echo "$settings" | cut -d: -f1)

    # Ensure WAN interface is in excluded list for exclude mode
    if [ "$mode" = "exclude" ]; then
        ensure_wan_excluded
    fi

    # Extract server IPs and fake-ip range
    local server_ips fake_ip_range
    server_ips=$(extract_server_ips)
    fake_ip_range=$(extract_fake_ip_range)

    # Check if server_ips variable is non-empty directly
    if [ -n "$server_ips" ]; then
        msg "Extracted server IPs: $(echo "$server_ips" | tr '\n' ' ')"
    else
        msg "WARNING: No server IPs extracted from config"
    fi

    if [ -n "$fake_ip_range" ]; then
        msg "Detected fake-ip range: $fake_ip_range - TPROXY will be applied only to this range"
    else
        msg "No fake-ip configuration detected - TPROXY will be applied to all traffic"
    fi

    if hash nft 2>/dev/null; then
        msg "Using nftables for traffic redirection"
        if apply_nft_rules "$server_ips" "$fake_ip_range"; then
            ip route add local default dev lo table 100 2>/dev/null
            ip rule add fwmark 0x0001 table 100 2>/dev/null
        else
            msg "ERROR: Failed to apply nftables rules"
            return 1
        fi
    elif hash iptables 2>/dev/null; then
        msg "Using iptables for traffic redirection"
        if apply_iptables_rules "$server_ips" "$fake_ip_range"; then
            ip route add local default dev lo table 100 2>/dev/null
            ip rule add fwmark 0x0001 table 100 2>/dev/null
        else
            msg "ERROR: Failed to apply iptables rules"
            return 1
        fi
    else
        msg "ERROR: Neither nftables nor iptables found"
        return 1
    fi

    msg "Clash rules script started successfully"
}

stop() {
    msg "Stopping Clash rules script"

    if hash nft 2>/dev/null; then
        nft delete table ip clash 2>/dev/null
        ip route del local default dev lo table 100 2>/dev/null
        ip rule del fwmark 0x0001 table 100 2>/dev/null
        msg "nftables rules removed successfully"
    elif hash iptables 2>/dev/null; then
        # Check if QUIC blocking was enabled before trying to remove rules
        local settings block_quic
        settings=$(load_settings)
        block_quic=$(echo "$settings" | cut -d: -f4)

        if [ "$block_quic" = "true" ]; then
            iptables -t filter -D INPUT -p udp --dport 443 -j REJECT 2>/dev/null
            iptables -t filter -D FORWARD -p udp --dport 443 -j REJECT 2>/dev/null
        fi

        iptables -t mangle -D PREROUTING -j CLASH 2>/dev/null
        iptables -t mangle -F CLASH 2>/dev/null
        iptables -t mangle -X CLASH 2>/dev/null
        iptables -t mangle -F CLASH_PROCESS 2>/dev/null
        iptables -t mangle -X CLASH_PROCESS 2>/dev/null
        iptables -t mangle -D OUTPUT -j CLASH_LOCAL 2>/dev/null
        iptables -t mangle -F CLASH_LOCAL 2>/dev/null
        iptables -t mangle -X CLASH_LOCAL 2>/dev/null
        ip route del local default dev lo table 100 2>/dev/null
        ip rule del fwmark 0x0001 table 100 2>/dev/null
        msg "iptables rules removed successfully"
    else
        msg "ERROR: Neither nftables nor iptables found"
        return 1
    fi

    msg "Clash rules script stopped successfully"
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    *)
        echo "Usage: $0 {start|stop}"
        exit 1
        ;;
esac
